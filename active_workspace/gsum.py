# Исполнитель Джысум преобразует число, записанное на экране.
# У исполнителя есть три команды, которым присвоены номера:
# 1. Прибавить значение младшего разряда
# 2. Умножить на значение старшего разряда
# 3. Прибавить разность большего и меньшего по значению разрядов
# Первая команда не применима к числам, кратным 10.
# Вторая команда не применима к числам, меньшим 20.
# Например, при применении команды 1 к числу 19 получим число 28,
# при применении команды 2 к числу 22 – 44, команды 3 к 41 – 44.
# Сколько существует таких программ, которые
# исходное число 21 преобразуют в число 62?

# Первое, что мы заметим, что любая из команд:
# 1, 2, 3 — увеличивает исходное число.
# А это значит, что если мы должны прийти из 21(X) → 62(Y) и X > Y,
# то наша функция, при помощи которой мы будем искать количество маршрутов,
# должна вернуть (0).

# Если X == Y, то есть если мы уже пришли в 62, то функция должна вернуть (1)

# Теперь давай реверсируем алгоритм, постараемся понять, чему же равна наша
# сумма маршрутов для каждого Y. Максимальное значение маршрутов будет
# не более, чем 61 * 6 = 366 машрутов

# Заводим список, в котором будем хранить количество маршрутов для каждого X
NumberOfRoutes = [0] * 367

# Считаем количество маршрутов для X = 21 равным 1 (т.к. идем из него)
NumberOfRoutes[21] = 1

# Теперь пройдем все значения X от 21 до 61 включительно
for i in range(21, 62):
    if i % 10 != 0:  # проверяем, что число не кратно 10
        NumberOfRoutes[i + i % 10] += NumberOfRoutes[i]  # для команды 1
    if i > 19:  # проверяем, что число не меньше 20
        NumberOfRoutes[i * (i // 10)] += NumberOfRoutes[i]  # для команды 2
    # для команды 3 — модуль разности между первым и вторым разрядом и
    # будет искомой операцией
    if i % 10 != i // 10:  # проверяем, что цифры не одинаковые (иначе операция лишена смысла)
        NumberOfRoutes[i + abs(i // 10 - i % 10)] += NumberOfRoutes[i]

print(NumberOfRoutes[62])  # выводим количество маршрутов для попадания в Y = 62
